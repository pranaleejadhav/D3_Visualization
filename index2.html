<!DOCTYPE html>
<style>

.states :hover {
  fill: red;
}

.state-borders {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
  pointer-events: none;
}


.states :hover {
  fill: red;
}

.state-borders {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
  pointer-events: none;
}

.categories {
  fill: none;
  stroke: #fff;
  stroke-linejoin: round;
}

.categories-choropleth {
  fill: #ccc;
}

#tooltip-container {
  position: absolute;
  background-color: #fff;
  color: #000;
  padding: 10px;
  border: 1px solid;
  display: none;
}

#canvas svg {
  border: 0px;
}

.tooltip_key {
  font-weight: bold;
}

.tooltip_value {
  margin-left: 20px;
  float: right;
}

.x-axis {
  fill: #000;
}

</style>

<div id="tooltip-container"></div>

<div id="canvas-svg"></div>


<svg width="960" height="600"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

<script>

var svg = d3.select("svg");

var path = d3.geoPath();


d3.csv("https://raw.githubusercontent.com/pranaleejadhav/D3_Visualization/master/losses2015_transformed.csv?token=AVPWBJ1b6N9DpjxwSVsGCxvUh6-_Ot1-ks5bt7YUwA%3D%3D", function(err, data) {

 mydata = d3.nest()
                            .key(function(d) { return d.Damage_Descp;})
                            .rollup(function(d) {  //rollup --->sum the values -->aggreagte
                              return d3.sum(d, function(g) {return g.Amount; });
                            })
                            .entries(data);    

                            console.log(mydata);


d3.json("https://d3js.org/us-10m.v1.json", function(error, us) {
  if (error) throw error;

  name_id_map = {};
  id_name_map = {};
  
  for (var i = 0; i < mydata.length; i++) {

            var dataState = mydata[i].key;
            
            //Grab data value, and convert from string to float
            var dataValue = mydata[i].value;

            console.log(mydata[i].key);
            console.log("jhgjg ");

            console.log(dataValue);


            name_id_map[dataState] = dataValue;
            //Find the corresponding state inside the GeoJSON



            for (var j = 0; j < us.objects.states.length; j++) {
              var jsonState = us.objects.states[j].id;
        
              if (dataState == jsonState) {
            
                //Copy the data value into the JSON
                us.states[j].properties.value = dataValue;
                
                //Stop looking through the JSON
                break;
                
              }
            }


   // name_id_map[names[i].name] = names[i].id;
   // id_name_map[names[i].id] = names[i].name;
  }


console.log(name_id_map);
  //console.log(mydata[0].key);

   
  /*
  data.forEach(function(d) {
    var id = name_id_map[d[MAP_CATEGORY]];
    valueById.set(id, +d[MAP_VALUE]); 
  });
*/
       /* svg.append("g")
            .attr("class", "states")
          .selectAll("path")
          .data(topojson.feature(us, us.objects.states).features)
          .enter().append("path")
            .attr("d", path);

        svg.append("path")
            .attr("class", "state-borders")
            .attr("d", path(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; })));*/
            var SCALE = 0.7;
        svg.append("g")
        .attr("class", "categories-choropleth")
      .selectAll("path")
        .data(topojson.feature(us, us.objects.states).features)
      .enter().append("path")
       // .attr("transform", "scale(" + SCALE + ")")
       /* .style("fill", function(d) {
          if (valueById.get(d.id)) {
            var i = quantize(valueById.get(d.id));
            var color = colors[i].getColors();
            return "rgb(" + color.r + "," + color.g +
                "," + color.b + ")";
          } else {
            return "";
          }
        })*/
        .attr("d", path)
        .on("mousemove", function(d) {
            var html = "";
  
            html += "<div class=\"tooltip_kv\">";
            html += "<span class=\"tooltip_key\">";
            html += name_id_map[d.id];
            html += "</span>";
            html += "<span class=\"tooltip_value\">";
            html += "ghghb"//(valueById.get(d.id) ? valueById.get(d.id) : "");
            html += "";
            html += "</span>";
            html += "</div>";
            
            $("#tooltip-container").html(html);
            $(this).attr("fill-opacity", "0.8");
            $("#tooltip-container").show();
            
            var coordinates = d3.mouse(this);
            
            var map_width = $('.categories-choropleth')[0].getBoundingClientRect().width;
            
            if (d3.event.pageX < map_width / 2) {
              d3.select("#tooltip-container")
                .style("top", (d3.event.pageY + 15) + "px")
                .style("left", (d3.event.pageX + 15) + "px");
            } else {
              var tooltip_width = $("#tooltip-container").width();
              d3.select("#tooltip-container")
                .style("top", (d3.event.pageY + 15) + "px")
                .style("left", (d3.event.pageX - tooltip_width - 30) + "px");
            }
        })
        .on("mouseout", function() {
                $(this).attr("fill-opacity", "1.0");
                $("#tooltip-container").hide();
            });
  
    svg.append("path")
        .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
        .attr("class", "categories")
       // .attr("transform", "scale(" + SCALE + ")")
        .attr("d", path);    
});

});

</script>